Team Members: Suleyman Saib (on an AMD processor)


#################################
Assignment 1
#################################

Question 1: I was the only member of this team

Question 2:

Setting up the virtual machine
- Installed VMWare Workstation Pro 16
- Downloaded the latest version of Ubuntu LTS
- Started a new virtual machine on VMWare using the version of Ubuntu I had installed
- Ran “sudo apt-get install build-essential procps curl file git” in Terminal in order to get a few tools ready for cloning repositories and other fun command line shenanigans
- Ran “sudo apt-get install libncurses-dev gawk flex bison openssl libssl-dev dkms libelf-dev libudev-dev libpci-dev libiberty-dev autoconf”
- Ran “git clone https://github.com/saib-s/linux.git” to clone my fork of the linux repository onto my virtual machine 
- (optional) Watched my favorite show for about 25 minutes because this took a little while
- Opened the AMD64 Architecture Programmer’s Manual, went over to Volume 3, Appendix E, and began copying over the features that each of the named registers keep  track of. 
- Basic SVM information (0x8000000A(%eax)) can be found on page 625
- Wrote a separate function to print the SVM revision number, creatively named "revision_num_printer"
- SVM Basic Features (0x8000000A(%edx)) can be found on pages 625-626
- SVM extended features (0x8000001A(%eax)) can be found on page 627
- SVM encrypted VM features (0x8000001F(various)) can be found on pages 634-635
- While the assignment specifications mention that these features are spread across various registers, the APM only keeps track of whether or not a feature is supported in EAX. The other registers store locations and the maximum quantities of certain variables, and so I limited my solution to the EAX register.
- Ran the code and checked results
- Run “make”
- Run “sudo insmod ./cmpe283-1.ko”
- Run “dmesg” to see results
- Realize that the Makefile conflicts with the one provided by the professor, I ran my .c file in a separate directory since that's how you showed it
in the how-to video. The Makefile in this repo is the one from the default linux repo. If you want to test this code (contained in cmpe283-1.c)
you'll need to use the Makefile you've provided on Canvas, which I did not edit.
- Added files to git repo and made numerous edits with clarifications.

#################################
Assignment 2
#################################

Question 1: I was the only member of this team

Question 2:

The following are done after having a setup from assignment 1 above.

Repo setup
Run “apt-get install build-essential kernel-package fakeroot libncurses5-dev libssl-dev ccache bison flex libelf-dev”
Run “cp /boot/config-5.8.0-50-generic ./.config”
Run “make oldconfig”
Run “make -j 8 modules && make -j 8 && sudo make modules_install && sudo make install”
This takes a bit
Go to vmx.c
Include linux/sched/clock.h
Create two global variables to track exits (uint32_t) and exit process time
In vmx_exit(), increment both using ++ and clock()
Go to cpuid.c
In kvm_emulate_cpuid(), add an if statement for when eax == 0x4FFFFFFF
Read the two variables using extern into the registers
Make sure the regular cpuid handler is contained in the else statement

Question 3:

It appears that certain actions (like lots of input and output from devices) will result in higher numbers of exits.
I was unable to capture the number of exits in a full boot, but I would assume that they would be lower than expected since 
it's able to handle itself without the user interfering.


#################################
Assignment 3
#################################

Question 1: I was the only member of this team

Question 2: Following the steps in the example setup video
- Added a line in /arch/x86/kvm/cpuid.c that caught CPUID values for when eax equals 0x4ffffffe and output the number of exits stored in ecx
- Added a line in /arch/x86/kvm/svm/svm.c that increments a value in an array for an appropriate exit code in order to track the number of exits
- Created external variables that connect the two files over the array for the number of exits

Question 3:

It appears that certain actions (like lots of input and output from devices) will result in higher numbers of exits.
I was unable to capture the number of exits in a full boot (my virtual machine imploded, I have to load from snapshots every time :( no idea why), but I would assume that they would be lower than expected since 
it's able to handle itself without the user interfering.
